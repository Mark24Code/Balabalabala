# 数据类型

----
## 1.数据类型

ES5有5种简单数据类型（也称作基本数据类型）:

* Undefined
* Null
* Boolean
* Number
* String

ES6添加了一个

* Symbol

还有一种复杂的数据类型类型

* Object

---

### Q&A:

1. 这么少的数据类型，够表示所有数据么？

> 由于ES数据类型具有动态性，因此的确没有再定义其他数据类型的必要。——《红宝书(3rd)》P23


---
## 2.判断数据类型的方法

### 2.1 typeof 操作符
可能返回的字符:

* "undefined" 未定义
* "boolean" 布尔值
* "string" 字符串
* "number" 数字
* "object" _对象 或 null_ (这里具有两种含义，null其实就是空对象，这样就好理解了)
* "function" 函数

typeof是个操作符，可以这样 `typeof('test')` 或者 `typeof 'test'`

---
## 3.类型讲解

### 3.1 Undefined类型

Undefined只有一个值，就是undefined。var声明变量，但是未初始化，这个变量值就是 undefinded。

```Javascript
var message;
console.log(message); // >>> undefined
```

#### Tips:

一般不会显示的把值设置为 undefined（我个人觉得因为只要声明未赋值/初始化他就是undefined，undefined是一个变量的常态）。
后面的null恰好相反，这里提下，只要意在保存对象的变量还没有保存真正的对象，就该明确赋值为null，这样就恰好区分了 null和 undefined。

#### Q&A:
* undefined的作用是什么？

> [A]:ES3引入这个值是为了正式区分空对象指针（null）和未初始化的变量。

* 研究基础类型的意义是什么？

> [A]:我觉得是判断,基础类型是判断逻辑的基石，能够反映状态。掌握熟练地基础类型Boolean状态，是写复杂业务逻辑的基础。


### 3.2 Null类型

Null也是一个只有一个值的数据类型。从逻辑角度null值，表示一个空对象的指针，这也正是`typeof null`会返回`"object"`的原因。

```Javascript
var car = null;
console.log(typeof car); // >>> "object"
```

如果定义变量，准备将来用于保存对象，那么最好将该变量，初始化为null而不是其他值。这样，只要检查null的值，就知道是否已经保存了一个变量的引用。

```JavaScript
if(car !== null){
    //某些操作
}
```


#### 注意:

undefined的是派生自 null的。因此ES2 规定：

```JavaScript
null == undefined // true
```


#### Tips：
再提及
> 一般不会显示的把值设置为 undefined（我个人觉得因为只要声明未赋值/初始化他就是undefined，undefined是一个变量的常态）。
后面的null恰好相反，这里提下，只要意在保存对象的变量还没有保存真正的对象，就该明确赋值为null，这样就恰好区分了 null和 undefined。

### 3.3 Boolean类型

Boolean类型只有两个字面值 true，false，大小写敏感。

虽然Boolean类型的字面值只有两个，但是ES中所有类型的值都与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean(),例如：

```JavaScript
var msg = "hello world";
var msgBool = Boolean(msg);
```

可以对任何类型的值，调用Boolean()函数，而且总会返回一个Boolean值。至于返回值是true还是false，取决于要转化数据类型和其实际的值。

#### Tips:
这点并不是很无聊，实际上非常重要。因为在业务逻辑的判断中，明确这些能少走弯路。ES设计的过于松散，所以在一些边界的逻辑判断中会显得啰嗦。


数值类型 | 转换为true的值 | 转换为false的值
----|------|-----
Boolean | true | false
String |任何非空字符串 | ""(空字符串)
Number | 任何非零数字值（包括无穷大）| 0 和 NaN(后面再说NaN)
Object | 任何对象 | null
Undefined | 无 |  undefined

### 3.4 Number类型


Number类型，使用证书和浮点数。
看下字面量值

类型 | 声明方式 | 说明
----|-----|-----
整数(十进制) | var intNum = 55; | 直接声明
八进制 | 070(八进制56),079(无效，解析为79)，08(解析为 8)  | 八进制字面值第一位必须是0，数字序列是0~7，如果字面值中，数字超出范围，前导0将会被忽略，后面值当做十进制解析。八进制在严格模式下，字面量无效。
十六进制 | 0xA(十六进制10)，0x1f(十六进制31)  | 十六进制前两位必须是0x,后面跟着任何（0~9，A~F不区分大小写）

+0 和 -0 会被保存，并且认为相等

#### 3.4.1 浮点数值

浮点数值必须包含一个小数点，后面至少有一位数字。小数点前面可以没有整数，但是不推荐这种写法。

例如:

* 1.1
* 0.1
* .1 不推荐

浮点数的内存是整形的两倍，ES会自己根据情况保存为整数

* 1.解析为1
* 10.0解析为10

科学计数法

```JavaScript
var floatNum = 3.125e7 // 3.125*(10^7);
var floatNum = 3.125e-7 // 3.125*(10^-7)
```


浮点数值的高精度是17位小数，数值计算的时候，会存在问题，不像整数：

0.1+0.2的结果不是0.3 而是 0.300....04

#### 注意：这个问题会让你无法测试特定的浮点数值,例如：

```JavaScript
if(a+b==0.3){
    //do sth.
}
```

#### 浮点误差说明:
这个问题在于使用IEEE754数值浮点计算的问题。其他采用相同数值格式的语言，也会存在统一的问题。

#### 点评：Python在这里做了处理。以前学习过C的时候，我们就应该明白，计算机中对于浮点数的等同判断要单独处理。

```JavaScript
if((a+b-0.3)<1e-5){
    //do sth.
}

//1e-5 中 5是是允许的精度
```


数值范围的存在：内存中存着这两个值，`(Number.MIN_VALUE,Number.MAX_VALUE)`,浏览器里一般是 `(5e-324,1.7976931348623157e+308)` 如果在范围玩不得，会自动变成 `-Infinity`或者`Infinity`。

带来的问题：

如果某次计算中返回了正或者负Infinity，该值将无法继续参与下一次的计算。

可以用 `isFinite()` 函数来做 布尔判断，这个数是否在范围中。

#### 3.4.2 NaN

NaN 即非数值(Not a Number)，是一个特殊的数值。
_这个数值用于表示一个本来要返回数值的操作数，从未返回数值的情况（这样就不会爆出错误了）_

例如:在其他编程语言中，任意数除以0会异常中断，但是在ES中，会返回NaN,不会影响其他代码。

#### 注意:

NaN的特别之处：

* 任何涉及NaN的操作，都会返回NaN，这个特点在多步计算中有可能导致问题

* NaN与任何值都不想等，包括NaN本身。

```JavaScript
NaN == NaN //false
```

针对NaN的特点，ES定义了 isNaN()函数。这个函数接收一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否『不是数值』。isNaN()拿到参数会尝试将这个值转为数值。某些不是数值的值，会直接转为数值，"10",Boolean都会转为对应的数值。那些不能转为数值的值，都会导致这个函数返回 true。

```JavaScript
isNaN(NaN); //true
isNaN(10);  //false  10他是一个数值
isNaN("10"); //false "10"字符串可以转
isNaN("blue");//true 不能转
isNaN(true);// false 因为 true会被转为数值1
```

#### 注意:

isNaN也可以用在对象上。

他首先会调用对象的valueOf() 方法，然后看他的返回值是否可以转换为数值。如果不能，再给予这个返回值，再调用toString()方法，再测试返回值。

这也是ES种内置函数和操作符的一般执行流程。

> 更多看 3.5节《红3》 P30页


#### 3.4.3 数值转换

有三个函数可以把非数值转为数值: Number(),parseInt 和 parseFloat()。

* Number() 可以用于任何数据类型
* parseInt,parseFloat 用于把字符串转成数值。

_这三个对于同样的输入会有不同的返回结果。_

> #### 评价：
我一路敲到现在，ES松散型，看客也能感受到。每个方法，就像补丁一样打上去，返回的差异性很大。能感受到，内部存在不一致。ES是一个打补丁似的组成。不过不重要了。谁让浏览器只能用这种呢。不论是内聚的一致性设计，还是松散补丁式，只要能够让逻辑闭环，他就是可以用的。逻辑上不存在差别。ES的形式判断上可能多点。JS坑就坑在这种内在的不一致吧。没有内部统一的哲学，所以很细碎。




#### (1) Number() 的转换规则:

* Boolean:true和false将会变成 1和0
* 数值:简单的返回
* null:返回0
* undefined:返回NaN
* 字符串:
    * 如果字符串只包含数字,包括正负。怎会转为十进制。前导0被忽略。"011"变成11
    * 如果是有效浮点数，转为浮点数，前导0被忽略。"1.1"变成1.1
    * 如果包含有效的十六进制:"0xf" 则会转为相同大小的十进制整数
    * 空字符串 返回0
    * 上述之外的字符串，返回 NaN
    * 如果是对象，调用对象valueOf对返回值使用上述转化。如果返回是NaN,再次调用对象的toString（）方法，再次依照前面的返回值返回。

```JavaScript

Number("Hello World");//NaN
Number("");//0
Number(" ");//0
Number("000111");//111
Number(true);//1
Number(false);//0

Number(undefined);//NaN
Number(null);//0
```



#### 评价
我觉得要对东西有可观的判断，不唯上也不唯下。ES并不是一个设计很好的语言。
Number()函数在转换字符串的时候比较复杂且不合理。因此在处理证书的时候，更常用的是parseInt()函数。


#### (2) parseInt() 的转换规则:


parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。他会忽略字符串前面的空格，直到找到第一个非空的字符串。`注意` 如果第一个不是数字或者负号，就会返回NaN。如果第一个是数字字符，会解析下面的，直到非数字字符。`1234blue`会被转为`1234`。
如果第一个数字是数字字符，parseInt()也能够识别出各种整数格式(前面的 十进制，八进制和十六进制)。即"0x"开头会被解析为十六进制，"0"开头解析为八进制。

一些例子：

```JavaScript

parseInt("1234blue");//1234
parseInt("");//NaN
parseInt("0xA");//10(十六进制数)
parseInt(22.5);//22

parseInt("0xf");//字符串 解析为:15
parseInt(0xf);//字符串 解析为: 15

```

字符串八进制，ES3和ES5存在分歧

```JavaScript

parseInt("070");//字符串 解析为:70  ES5+
parseInt("070");//字符串 解析为:56  ES3
parseInt(070);//字符串 解析为: 56

```

为了消除歧义，parseInt的第二个参数，可以控制转化

```JavaScript

parseInt("070",8);//字符串 解析为:56
parseInt("0xaf",16);//字符串 解析为:175
parseInt("AF",16);//字符串，可以不带0x 解析为: 175

```

#### (3) parseFloat() 的转换规则:

parseFloat()也是从第一个字符(位置0)开始解析每个字符，而且也是一直解析到字符串末尾，或者解析到第一个无效的浮点字符位置。第一个小数点有效，第二个小数点无效了。后面的字符串将会被忽略。

`11.34.5` 会被转换成 11.34



parseFloat和parseInt的区别:

* parseFloat 解析第一个小数点
* parseFloat 始终忽略前导的零
* parseFloat 只解析十进制，所以十六进制的0会被忽略，没有第二个参数定基。

例子：

```JavaScript
parseFloat("1234blue");//1234(证书)
parseFloat("0xA");//0
parseFloat("22.5");//22.5
parseFloat("22.34.5");//22.34
parseFloat("0908.5");//908.5
parseFloat("3.124e7");//32150000
```











